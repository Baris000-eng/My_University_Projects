

Notice: Since we are using math library, please run the code with -lm flag

EXPLANATION OF THE PART-1 & EXPLANATION OF THE PART-2 & EXPLANATION OF THE MAIN
The moderator function starts with a for loop, this for loop is to allow moderator thread to ask all question before it terminates. It first waits for the semaphore "mod". This semaphore "mod" is initialized to 1 at the beginning so that the moderator can start the talking show, and there is no commentator function executing before him. Then there is the mutex lock "mutex" to control only one person talking at a time. The moderator gets that mutex too. The moderator resets the numComAns and numQueue to zero. numComAns holds the number of commentators that have asked their questions. If this is equal to the number of commentators, then it means that all the commentators tried their chances to talk(if they decided to talk), this numComAns is for returning back to moderator when all the commentators answered the question (if they have decided to). The numQueue is for holding the queue of the commentators which have decided to speak. When a commentator decides to speak the numQueue is incremented. After moderator resets numComAns and numQueue, the moderator asks the question. Then it releases the mutex and signals the commentator to speak, basically the moderator signals the com semaphore which is used to wake up commentator threads. At the end, before going to the other for loop iteration (asking the other question), it waits for the barrier, this barrier holds all the commentators and the moderator, so no continuous questions are asked before a commentator answers, or commentators do not answer the question at the same time. And at the end of the for loop, which means that all the questions have been asked and the commentators have generated their answers, we keep a variable, which is named alive, this is for keep running the b_event_funciton thread, and after all the questions are asked, we make alive 0, which is inside the while loop in the breaking event thread, when alive becomes 0, the while loop terminates and the thread that controls the breaking event, b_event_function, can finish the execution of its function so that we can join all the threads at the end of the main function.

The commentator function has an argument parameter inside it, which is its index, this is for determining which commentator is speaking at the time. Commentator threads always wait for the com signal before start, this semaphore is initialized to 0 at the beginning of the program. After the moderator asks its question, it signals the com semaphore so that the commentators start talking. Also commentator threads have a for loop which iterates as many time as the number of questions, so that they do not finish their execution before all the questions are asked. After the com signal, the commentator also gets the mutex, so that no two commentator or no commentator and moderator are talking at the same time (in this case it is race condition) then double variable pr is initialized. It is used for determining whether or not the commentator thread is going to speak. Then we also initialize the breaking_news_happened to 0. This variable helps us to see whether or not the commentators answer is cut short, and depending on if it is cut short or not, we go on to the next commentator or the breaking news happens. Then, if the commentator is going to speak, we get the random double speak time for the commentator and partition it to integer and fraction part. Then again we have a random variable which is br, this stores the probability of breaking event happening. We get the number with a random number between 0 and 1. We keep getting a random number for every second that commentator speaks. This is to check if breaking event occurred or not, every second. If breaking event occurs then we go to the breaking event thread, if it does not occur, the thread sleeps for speak_time which is the random double value that is between 1 and the command line input which is for the maximum speaking time for the commentator. We go to the breaking event thread, which is the void function named b_event_funciton by sending a signal, and waiting for another signal, so after sending the signal b_event_function starts executing and we wait for the signal which will be sent from the b_event_function. Then at the end we look for how many commentators had the chance to speak. numComAns stores the number of commentators that have tried to speak for the current question. At every iteration we increment numComAns by 1, which stores the current number of commentators that have tried to answer. Then we check if numComAns is smaller than the commentatorNum (commentatorNum stores the total number of commentators.) or not. If it is smaller, then we signal another commentator, because not all the commentators have tried to answer the question. But if it is not smaller than the commentatorNum, then we signal the moderator, so that moderator can ask the next question. And also we have a barrier, the barrier that we had in the moderator thread, so that every commentator thread and the moderator thread waits for the next question and there is an order. And of course, at the end we free the args.

The breaking events is done by a thread. The void function of the breaking event thread is b_event_function. When it is called, it uses pthread_sleep() function to show that breaking event is occurring. It is in a while loop which has the global variable "alive" inside the while. The while loop goes until every question is asked and every commentator have answered the questions, so that there is no more breaking event cut shorts. The thread waits for the b_event signal, then signals back the caller with b_event_2. And when the moderator asks the last question and the commentators all answer the question, the moderator sets the global variable "alive" to zero. And signals the b_event_function one last time, so that b_event_function stop the execution and all the threads can join at the end of the program.

As for the main program, we start by getting all the command inputs and store them inside global variables. Then we initialize all the semaphores, barriers, mutex, and threads. Then we join all the threads so that program functions properly. And destroy all the mutex, barrier, and semaphores.



For the logging part, we create type int microseconds and milliseconds. We have three struct timeval, namely tv, tv2, tv3. The tv variable is initialized at the beginning of the program. We use it to get a reference for how much seconds and miliseconds have passed since the beginning. Then we initialze tv2 and tv3. tv2 is for getting the current time, and then we initialize tv3 as their difference. This way we can get all the times starting from (00:00:00). Then using a buffer and strftime, we create the log and simply print it with printf at the beginnign of every necessary action.

Which parts work?  Every part works except for the queueing the commentators. We managed to implement the other parts.
